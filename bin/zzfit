#!/usr/bin/env python

from desispec.log import get_logger
from desispec.io.brick import Brick
from desispec.resolution import Resolution
from desispec.io.util import native_endian

import argparse
import numpy as np
import sys
import math
from astropy.io import fits
from zztop.line_scan import zz_line_scan
import zztop.io as io


def main() :

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--b', type = str, default = None, required=True,
                        help = 'path of DESI brick in b')
    parser.add_argument('--r', type = str, default = None, required=True,
                        help = 'path of DESI brick in r')
    parser.add_argument('--z', type = str, default = None, required=True,
                        help = 'path of DESI brick in z')
    parser.add_argument('--outfile', type = str, default = None, required=True,
                        help = 'path of output file')
    parser.add_argument('--nspec', type = int, default = None, required=False,
                        help = 'max number of spectra to fit')
    parser.add_argument('--first', type = int, default = 0, required=False,
                        help = 'first spectrum to fit')
    parser.add_argument('--use-true-flux', action = 'store_true',
                        help = 'use true flux for debugging if exists in bricks')
    
    
    args = parser.parse_args()
    log=get_logger()

    log.info("starting")

    

    b_brick=Brick(args.b)
    r_brick=Brick(args.r)
    z_brick=Brick(args.z)
    
    elg_spectra=np.where(b_brick.hdu_list[7].data["OBJTYPE"][args.first:]=="ELG")[0]+args.first
    
    #########################################
    ## fit parameters
    #########################################
    lines=np.array([3727.092,3729.875,4862.708,4960.295,5008.240,6564.603])
    vdisps=90.*np.ones(lines.size) # same velocity dispersion , in km/s (can do different)
    zstep=0.001 # z step of the scan
    zmin=0.3 # min redshift of the scan
    zmax=2. # max redshift of the scan
    wave_nsig=3. # nsigma for profile fit (based on resolution and chosen velocity dispersion)
    ntrack=5 # number of solutions to track 
    
    
    # line ratio priors are included in the chi2 fit, it makes sense only for doublets
    # line_ratio_priors[INDEX_OF_LINE_2]=[INDEX_OF_LINE_1,min(LINE_2/LINE_1),max(LINE_2/LINE_1),conserve_sum_of_fluxes]
    line_ratio_priors={} 
    line_ratio_priors[1]=[0,0.6,0.85,True] # prior on 3729/3727 line ratio 
    
    # line ratio constraints are used to rank best fits among the few solutions that are found based on chi2
    # line_ratio_constraints[INDEX_OF_LINE_2]=[INDEX_OF_LINE_1,min(LINE_2/LINE_1),max(LINE_2/LINE_1)]
    line_ratio_constraints={} 
    line_ratio_constraints[2]=[0,0.,1.] # constraint on 4862/3727 line ratio 
    line_ratio_constraints[3]=[0,0.,0.5] # constraint on 4862/3727 line ratio 
    line_ratio_constraints[4]=[0,0.,0.5] # constraint on 5008/3727 line ratio 
    # don't have 6564 in the training sample yet
    log.warning("line_ratio_constraints are not implemented yet")
    
    #########################################

    
    results=None

    truth_table_hdu=None
    try :
        b_hdulist = fits.open(args.b)
        truth_table_hdu=b_hdulist["_TRUTH"]
        log.info("brick has truth table")
    except KeyError :
        truth_table_hdu=None
        
    if args.nspec is not None :
        nspec = min(args.nspec,elg_spectra.size)
    else :
        nspec=elg_spectra.size
    
    log.info("will fit %d spectra"%nspec)


    for spec,s in zip(elg_spectra[:nspec],range(nspec)) :


        flux=[b_brick.hdu_list[0].data[spec],r_brick.hdu_list[0].data[spec],z_brick.hdu_list[0].data[spec]]
        
        # for tests
        if args.use_true_flux:
            flux=[b_brick.hdu_list["_TRUEFLUX"].data[spec],r_brick.hdu_list["_TRUEFLUX"].data[spec],z_brick.hdu_list["_TRUEFLUX"].data[spec]]
        
        ivar=[b_brick.hdu_list[1].data[spec],r_brick.hdu_list[1].data[spec],z_brick.hdu_list[1].data[spec]]
        wave=[b_brick.hdu_list[2].data,r_brick.hdu_list[2].data,z_brick.hdu_list[2].data]    
        resolution=[Resolution(native_endian(b_brick.hdu_list[3].data[spec])),Resolution(native_endian(r_brick.hdu_list[3].data[spec])),Resolution(native_endian(z_brick.hdu_list[3].data[spec]))]
        result = zz_line_scan(wave=wave,flux=flux,ivar=ivar,resolution=resolution,
                              lines=lines,vdisps=vdisps,line_ratio_priors=line_ratio_priors,
                              line_ratio_constraints=line_ratio_constraints,
                              zstep=zstep,zmin=zmin,zmax=zmax,wave_nsig=wave_nsig,ntrack=ntrack,recursive=True)
    
        if results is None :

            dtype = list()
            for key in result.keys() :
                dtype.append( (key, np.float32) ) # need to change this
            
            # add fit parameters
            dtype.append( ("VDISP", np.float32) )
            
            results = np.empty(nspec, dtype=dtype)
        for key in result.keys() :
            results[key][s]=result[key]
        results["VDISP"][s]=np.mean(vdisps) # need to change this if we want different velocity dispersion per line
        
        if truth_table_hdu is not None :
            log.info("%d fitted z=%f true z=%f\n"%(s,result["BEST_Z"],truth_table_hdu.data["TRUEZ"][spec]))
            # also need to compute the actual line fluxes
            


    brickname = args.b
    targetids = b_brick.get_target_ids()[:nspec]

        

    io.write_zbest(args.outfile,brickname,targetids,results,truth_table_hdu)
    log.info("wrote %s"%args.outfile)
    log.info("the end")
    

if __name__ == '__main__':
    main()
    

