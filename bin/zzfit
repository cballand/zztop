#!/usr/bin/env python

from desiutil.log import get_logger
from desispec.resolution import Resolution
from desispec.io.util import native_endian

import redrock.external.boss

import argparse
import numpy as np
import sys
import math
from astropy.io import fits
import zztop
from zztop.line_scan import zz_line_scan
import zztop.io as io
import multiprocessing
import json
import os.path
import h5py

def _func(arg) :
    return zz_line_scan(**arg)

def main() :

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--spPlate', type = str, default = None, required=True,
                        help = 'path to BOSS spPlate')
    parser.add_argument('--outfile', type = str, default = None, required=True,
                        help = 'path of output file')
    parser.add_argument('--nspec', type = int, default = None, required=False,
                        help = 'max number of spectra to fit')
    parser.add_argument('--first', type = int, default = 0, required=False,
                        help = 'first spectrum to fit')
    parser.add_argument('--use-truth', action = 'store_true',
                        help = 'use true flux and true vdisp for debugging if exists in bricks')
    parser.add_argument('--ncpu', type = int, default = 1, required=False,
                        help = 'multiprocessing')
    parser.add_argument('--conf', type = str, default = None, required=False,
                        help = 'configuration file')
    parser.add_argument('--type', type = str, default = "ELG", required=False,
                        help = 'configuration file')
    parser.add_argument('--prior_file', type = str, default = None, required=False,
                    help = 'prior info on redshift file')
    
    
    args = parser.parse_args()
    log=get_logger()

    log.info("starting")

    
    spplate_file = args.spPlate

    spect = redrock.external.boss.read_spectra(spplate_file)

    elg_spectra = np.array(range(len(spect[0])))
   
    #########################################
    ## fit parameters are in config file
    #########################################
    
    if args.conf is None :
        args.conf = "%s/data/zztop.json"%(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(zztop.__file__)))))
        log.info("will use default config file %s"%args.conf)
        
    try :
        file=open(args.conf)
        data = json.load(file)
        parameters=data["zztop"][args.type]
    except :
        log.error("error when parsing json file:")
        print (sys.exc_info())
        sys.exit(12)
        
    results=None

    truth_table_hdu=None
    try :
        b_hdulist = fits.open(args.spPlate)
        truth_table_hdu=b_hdulist["_TRUTH"]
        log.info("brick has truth table")
    except KeyError :
        truth_table_hdu=None
        
    if args.nspec is not None :
        nspec = min(args.nspec,elg_spectra.size)
    else :
        nspec=elg_spectra.size
        
    elg_spectra=elg_spectra[:nspec]
    alltargetids = spect[1][0][:]
    targetids = alltargetids[elg_spectra]
    
    log.info("will fit %d spectra"%nspec)
    
    func_args = []

        
    for spec,s in zip(elg_spectra,range(nspec)) :

        targetid=targetids[s]

        wave = [spect[0][spec].spectra[0].wave]
        flux = [spect[0][spec].spectra[0].flux]
        ivar = [spect[0][spec].spectra[0].ivar]
        resolution = [spect[0][spec].spectra[0].R]

        arguments={"targetid":targetid, "wave":wave,
                           "flux":flux,"ivar":ivar,"resolution":resolution}
        
        # add fit parameters found in configuration file
        for k in parameters :
            arguments[k]=parameters[k]                

        # if prior information on redshift (e.g., from another fitter), define new redshift range for fit
        if (args.prior_file):
            # Read redshift from file
            prior_info = h5py.File(args.prior_file,'r')
            zbest = prior_info['/zbest']
            ind, = np.where(zbest['TARGETID']==targetid)
            prior_z = zbest['Z'][ind]
            arguments["zmin"]=max(0.,prior_z-0.05)
            arguments["zmax"]=prior_z+0.05
#            print (targetid,prior_z)


        # for tests
        if args.use_truth :
            arguments["flux"]=[b_brick.hdu_list["_TRUEFLUX"].data[spec],r_brick.hdu_list["_TRUEFLUX"].data[spec],z_brick.hdu_list["_TRUEFLUX"].data[spec]]
            arguments["vdisps"]=[b_brick.hdu_list["_TRUTH"].data["VDISP"][spec]]
            arguments["zmin"]=b_brick.hdu_list["_TRUTH"].data["TRUEZ"][spec]-0.05
            arguments["zmax"]=b_brick.hdu_list["_TRUTH"].data["TRUEZ"][spec]+0.05
            arguments["ntrack"]=3
            arguments["fixed_line_ratio"]=[[0,1,b_brick.hdu_list["_TRUTH"].data["OIIDOUBLET"][spec]]]            
            if arguments.has_key("line_ratio_constraints") : arguments.pop("line_ratio_constraints") 
            if arguments.has_key("line_ratio_priors") : arguments.pop("line_ratio_priors") 
        
        # save all arguments for each spectrum in a list for multiprocessing 
        func_args.append( arguments )
    
    results=[]
    
    if args.ncpu==1 : # simple loop
        
        for arg,spec in zip(func_args,elg_spectra) :
            targetid=targetids[spec]
            result = zz_line_scan(**arg)
            results.append(result)
            
            if truth_table_hdu is not None :
                log.info("%d fitted z=%f true z=%f fitted oII=%f true oII=%f\n"%(spec,result["BEST_Z"],truth_table_hdu.data["TRUEZ"][spec],result["BEST_FLUX_3727A"]+result["BEST_FLUX_3729A"],truth_table_hdu.data["OIIFLUX"][spec]*1e17))
                
    else : # use multiprocessing
        
        log.info("starting multiprocessing with %d cpus"%args.ncpu)
        
        pool = multiprocessing.Pool(args.ncpu)
        results =  pool.map(_func, func_args)
        
    # reformat results matching initial target ids (multiprocessing shuffles the results)
    dtype = list()
    for key in results[0].keys() :
        if key=="TARGETID" :
            dtype.append( (key, np.int64) ) 
        elif key=="ZWARN" :
            dtype.append( (key, np.int64) ) 
        else :
            dtype.append( (key, np.float32) )
    formatted_results = np.empty(len(results), dtype=dtype)
    
    index_bad = list()
    for result,j in zip(results,range(nspec)) :
        if (result==(None,None)):
            print ("Zero flux spectrum")
            index_bad.append(j)
        else:
            i,=np.where(targetids==result["TARGETID"])
            print (i)
            for key in result.keys() :
                formatted_results[key][i]=result[key]
    
    new_formatted_results =np.delete(formatted_results,index_bad)
    formatted_results = new_formatted_results.copy()

    objtype='ELG'
    io.write_zbest(args.outfile,targetid,objtype,formatted_results,truth_table_hdu)
    log.info("wrote %s"%args.outfile)
    log.info("the end")
    

if __name__ == '__main__':
    main()
    

